<!doctype html>
<html lang="pl">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AWS VPC Argus</title>
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            background: #ffffff; 
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        .page { 
            display: flex; 
            align-items: center; 
            justify-content: center;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        }
        h1 { font-size: 18px; margin: 0 0 8px 0; }
        .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 10px; }
        .hint { color: #666; font-size: 12px; }
        network-chord-diagram { display: block; width: 100%; height: 100%; }
        .legend { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; font-size: 13px; }
        .lg { display: inline-flex; align-items: center; gap: 6px; }
        .sw { width: 14px; height: 14px; border-radius: 3px; display: inline-block; }
        .sw.b { background:#1f77b4; }
        .sw.r { background:#e74c3c; }
        .sw.g { background:#2ecc71; }
    </style>
</head>
<body>
<div class="page">
    <network-chord-diagram id="demo" width="307" height="307">
        <script type="application/json" id="chart-data">
{
  "groups": [],
  "interfaces": [],
  "traffic": []
}
        </script>
    </network-chord-diagram>
</div>

<script type="module">
// Load data from gather.js and convert to chart format
async function loadAndConvertData() {
    try {
        const response = await fetch('./gather.json');
        const gatherData = await response.json();
        
        // Extract network interfaces from gather data
        const networkInterfaces = gatherData.network_interfaces || [];
        
        // Group interfaces by resource type
        const groupedByType = {};
        networkInterfaces.forEach(eni => {
            const resourceType = eni.resource_type || 'unknown';
            if (!groupedByType[resourceType]) {
                groupedByType[resourceType] = [];
            }
            groupedByType[resourceType].push(eni);
        });
        
        // Define color mapping for resource types
        const colorMap = {
            'ec2': '#1f77b4',
            'eks': '#1f77b4',
            'eks-pod': '#1f77b4',
            'ecs': '#1f77b4',
            'lambda': '#1f77b4',
            'rds': '#2ecc71',
            'elasticache': '#2ecc71',
            'redshift': '#2ecc71',
            'elb': '#ff9800',
            'nat-gateway': '#ff9800',
            'igw': '#ff9800',
            'vpc-endpoint': '#9c27b0',
            'route53-resolver': '#9c27b0',
            'route53-resolver-inbound': '#9c27b0',
            'route53-resolver-outbound': '#9c27b0',
            'dns': '#9c27b0',
            'unknown': '#95a5a6'
        };
        
        // Create groups from resource types
        const groups = Object.keys(groupedByType).map(type => ({
            id: type,
            name: type.toUpperCase().replace(/-/g, ' '),
            color: colorMap[type] || '#95a5a6'
        }));
        
        // Create interfaces from ENIs
        const interfaces = networkInterfaces.map((eni, index) => {
            const resourceType = eni.resource_type || 'unknown';
            
            // Map resource types to visualization groups
            // IGW, NAT gateways, VPN gateways, peering -> 'gateways' group
            // VPC endpoints, DNS resolvers -> 'endpoints' group
            let group = resourceType;
            if (resourceType === 'igw' || resourceType === 'nat-gateway' || resourceType === 'vgw' || resourceType === 'peering') {
                group = 'gateways';
            } else if (resourceType === 'vpc-endpoint' || resourceType === 'dns' || resourceType.startsWith('route53-resolver')) {
                group = 'endpoints';
            }
            
            const interfaceData = {
                id: eni.id,
                name: `${eni.resource_name || eni.resource_id}/${eni.id}`,
                group: group,
                ips: eni.private_ip_addresses || [],
                publicIps: eni.public_ips || [],
                createdAt: eni.last_updated || new Date().toISOString(),
                subnetIds: eni.subnet_ids || {},
                azs: eni.azs || {},
                vpcId: eni.vpc_id,
                securityGroups: eni.security_group_ids || [],
                resourceType: resourceType,
                resourceId: eni.resource_id,
                resourceName: eni.resource_name,
                description: eni.description,
                tags: eni.resource_tags || {}
            };
            
            // Add type field if present (for virtual appliances)
            if (eni.type) {
                interfaceData.type = eni.type;
            }
            
            return interfaceData;
        });
        
        // Traffic will be added later
        const traffic = [];
        
        // Update the chart data
        const chartData = {
            groups,
            interfaces,
            traffic,
            metadata: gatherData.metadata || {}
        };
        
        // Update the script tag with new data
        const scriptTag = document.getElementById('chart-data');
        scriptTag.textContent = JSON.stringify(chartData, null, 2);
        
        // Trigger a custom event to notify the component
        const event = new CustomEvent('data-loaded', { detail: chartData });
        document.getElementById('demo').dispatchEvent(event);
        
        console.log('Data loaded successfully:', {
            groups: groups.length,
            interfaces: interfaces.length,
            traffic: traffic.length
        });
        
    } catch (error) {
        console.error('Error loading gather.js data:', error);
        // Keep the default empty data structure
    }
}

// Load data when page is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadAndConvertData);
} else {
    loadAndConvertData();
}
</script>
<script type="module" src="./js/app.js"></script>

</body>
</html>